---
name: codebase-cartography
description: >
  Auto-generate codebase maps for AI context — file trees, dependency graphs, and architectural overviews.
  Trigger: When starting work on unfamiliar codebase, onboarding, or when AI needs project overview context.
license: MIT
metadata:
  author: gentleman-programming
  version: "1.0"
---

# Codebase Cartography

Generate structured codebase maps (`codemap.md`) that give AI assistants instant architectural
context. Reduce hallucinations, speed up onboarding, and enable better code navigation by
providing a concise, token-efficient overview of any project.

---

## Core Principle

AI assistants perform dramatically better when they understand the shape of a codebase before
diving into specific files. Without context, agents:

- **Hallucinate file paths** — guessing at directory structures that don't exist.
- **Miss architectural patterns** — treating a hexagonal architecture like a monolith.
- **Waste token budget** — exploring irrelevant directories before finding the right code.
- **Lose session context** — re-discovering the same structure across conversations.

A `codemap.md` solves this by providing a **single, concise document** that captures:

1. **What** the project is (language, framework, purpose).
2. **How** it's organized (directory structure, modules, layers).
3. **Where** the important code lives (entry points, config, core logic).
4. **What** it depends on (external libraries, internal module graph).

This file acts as a **pre-loaded context document** — placed in the project root so AI tools
(Claude Code, OpenCode, Cursor, Aider) automatically ingest it before any task begins.

### Token Budget Rule

A good codemap should stay **under 2000 tokens** (~1500 words). This ensures it fits
comfortably in any AI context window without crowding out the actual task. For monorepos
or very large projects, generate per-package codemaps instead of one giant file.

---

## Codemap Output Format

The generated `codemap.md` follows a strict structure:

```markdown
# Codebase Map

> Auto-generated by codebase-cartography. Last updated: 2026-03-01

## Project Overview

- **Name**: my-project
- **Language**: TypeScript
- **Framework**: Next.js 15 (App Router)
- **Package Manager**: pnpm
- **Monorepo**: No
- **Test Framework**: Vitest + Playwright

## Architecture

Pattern: Feature-based modular architecture with App Router conventions.

Layers:
- `app/` — Route handlers, layouts, pages (server-first)
- `components/` — Shared UI components
- `lib/` — Business logic and utilities
- `services/` — External API integrations
- `hooks/` — Custom React hooks

## Directory Structure

```
my-project/
├── app/
│   ├── layout.tsx              # Root layout
│   ├── page.tsx                # Home page
│   ├── (auth)/
│   │   ├── login/page.tsx
│   │   └── register/page.tsx
│   └── dashboard/
│       ├── layout.tsx
│       └── page.tsx
├── components/
│   ├── ui/                     # Design system primitives
│   └── features/               # Feature-specific components
├── lib/
│   ├── db.ts                   # Database client
│   ├── auth.ts                 # Auth utilities
│   └── validators.ts           # Zod schemas
├── services/
│   └── api.ts                  # API client
├── hooks/
│   └── use-auth.ts
├── public/
├── next.config.ts
├── tailwind.config.ts
├── tsconfig.json
└── package.json
```

## Key Files

| File | Role |
|------|------|
| `app/layout.tsx` | Root layout, providers, metadata |
| `lib/db.ts` | Database connection (Drizzle + PostgreSQL) |
| `lib/auth.ts` | Authentication logic (NextAuth v5) |
| `next.config.ts` | Framework configuration |
| `package.json` | Dependencies and scripts |

## Dependencies (Key)

- **next** 15.x — Framework
- **react** 19.x — UI library
- **drizzle-orm** — Database ORM
- **next-auth** 5.x — Authentication
- **zod** 4.x — Validation
- **tailwindcss** 4.x — Styling

## Entry Points

- `app/layout.tsx` — Application shell
- `app/page.tsx` — Home route
- `next.config.ts` — Build configuration
- `middleware.ts` — Request middleware (auth guards)

## Patterns Detected

- Server Components by default (App Router)
- Route groups for auth flows `(auth)/`
- Collocated loading/error boundaries
- Barrel exports in `components/ui/index.ts`
- Environment variables via `.env.local`
```

---

## Framework-Specific Detection Rules

The cartography engine detects frameworks by examining marker files and directory patterns.

### React / Next.js

**Marker files**: `next.config.ts`, `next.config.js`, `next.config.mjs`

**Directory patterns**:
```
app/             → App Router (Next.js 13+)
pages/           → Pages Router (legacy)
components/      → UI components
hooks/           → Custom hooks
lib/ or utils/   → Shared utilities
public/          → Static assets
middleware.ts    → Edge middleware
```

**Key detection rules**:
- If `app/layout.tsx` exists → App Router architecture
- If `pages/_app.tsx` exists → Pages Router architecture
- If both exist → Hybrid (note in codemap)
- Check `next.config` for `experimental`, `serverActions`, `turbopack`

### Angular

**Marker files**: `angular.json`, `nx.json` (Nx workspace)

**Directory patterns**:
```
src/app/                → Application root
src/app/core/           → Singleton services, guards, interceptors
src/app/shared/         → Shared modules, pipes, directives
src/app/features/       → Feature modules (lazy-loaded)
src/environments/       → Environment configs
```

**Key detection rules**:
- Parse `angular.json` for project names and architect targets
- Detect standalone components vs NgModule-based
- Check for `provideRouter()` (standalone) vs `RouterModule` (NgModule)
- Identify state management: NgRx, Akita, or signal-based

### Spring Boot (Java/Kotlin)

**Marker files**: `pom.xml`, `build.gradle`, `build.gradle.kts`

**Directory patterns**:
```
src/main/java/com/example/
├── config/             → Configuration classes
├── controller/         → REST controllers
├── service/            → Business logic
├── repository/         → Data access (JPA/JDBC)
├── entity/ or model/   → Domain entities
├── dto/                → Data transfer objects
├── exception/          → Custom exceptions
└── security/           → Security configuration
```

**Key detection rules**:
- Check `@SpringBootApplication` annotation location → main entry point
- Detect architecture: layered, hexagonal, or DDD
- Parse `application.yml` / `application.properties` for profiles
- Identify Spring modules: Web, Security, Data JPA, Cloud

### Go

**Marker files**: `go.mod`, `go.sum`

**Directory patterns**:
```
cmd/                    → Application entry points
internal/               → Private application code
pkg/                    → Public library code
api/                    → API definitions (OpenAPI, proto)
configs/                → Configuration files
deployments/            → Docker, K8s manifests
```

**Key detection rules**:
- Parse `go.mod` for module path and Go version
- Find `func main()` locations → entry points
- Detect web framework: Chi, Gin, Echo, Fiber, stdlib
- Check for `internal/` (standard Go project layout)

### Python / Django / FastAPI

**Marker files**: `pyproject.toml`, `setup.py`, `requirements.txt`, `Pipfile`, `manage.py`

**Directory patterns (Django)**:
```
project/
├── manage.py           → Django management
├── project/
│   ├── settings.py     → Configuration
│   ├── urls.py         → URL routing
│   └── wsgi.py         → WSGI entry point
├── apps/
│   └── users/
│       ├── models.py
│       ├── views.py
│       ├── serializers.py
│       ├── urls.py
│       └── tests.py
```

**Directory patterns (FastAPI)**:
```
app/
├── main.py             → FastAPI application
├── routers/            → API route handlers
├── models/             → SQLAlchemy/Pydantic models
├── schemas/            → Pydantic schemas
├── services/           → Business logic
├── dependencies.py     → Dependency injection
└── config.py           → Settings (pydantic-settings)
```

**Key detection rules**:
- `manage.py` present → Django
- `uvicorn` or `fastapi` in dependencies → FastAPI
- `flask` in dependencies → Flask
- Check for `alembic/` → database migrations
- Detect test framework: pytest vs unittest

### Rust

**Marker files**: `Cargo.toml`, `Cargo.lock`

**Directory patterns**:
```
src/
├── main.rs             → Binary entry point
├── lib.rs              → Library entry point
├── bin/                → Multiple binary targets
└── modules/
```

**Key detection rules**:
- Parse `Cargo.toml` for `[workspace]` → workspace/monorepo
- Check `[lib]` vs `[[bin]]` sections → library or binary
- Detect web framework: Actix, Axum, Rocket, Warp
- Find `mod.rs` or module declarations for module graph
- Check for `build.rs` → custom build steps

---

## Smart Filtering Rules

### Always Exclude

These directories and files add noise without value:

```bash
# Dependency directories
node_modules/
vendor/
.venv/ venv/ env/
__pycache__/
.mypy_cache/
.pytest_cache/

# Build artifacts
build/ dist/ out/
.next/ .nuxt/
target/          # Rust/Java
*.class
*.pyc

# Version control
.git/
.hg/
.svn/

# IDE and editor
.idea/
.vscode/         # Exclude unless settings are project-critical
*.swp *.swo

# OS files
.DS_Store
Thumbs.db

# Lock files (mention existence, don't list contents)
package-lock.json
yarn.lock
pnpm-lock.yaml
Cargo.lock
poetry.lock
```

### Always Include

These files are architecturally significant:

```bash
# Configuration
*.config.ts *.config.js *.config.mjs
tsconfig.json jsconfig.json
angular.json
Cargo.toml go.mod pyproject.toml
Dockerfile docker-compose.yml
Makefile Justfile Taskfile.yml
.env.example

# Entry points
main.ts main.go main.rs main.py
index.ts index.js
App.tsx App.vue App.svelte
manage.py

# Documentation
README.md CLAUDE.md AGENTS.md
ARCHITECTURE.md CONTRIBUTING.md

# CI/CD
.github/workflows/
.gitlab-ci.yml
Jenkinsfile
```

### Depth Limits

To keep codemaps concise:

| Project Size       | Max Tree Depth | Max Files Listed |
|--------------------|----------------|------------------|
| Small (<100 files) | 5 levels       | All              |
| Medium (<1000)     | 3 levels       | 80-120           |
| Large (<10000)     | 2 levels       | 50-80            |
| Monorepo           | Per-package    | 30-50 per pkg    |

For large projects, show the **top 2 levels** fully, then only expand directories
that contain architecturally significant code (entry points, config, core domain).

---

## Dependency Analysis

### package.json (Node.js)

```bash
# Extract key dependencies (skip devDependencies for codemap)
jq -r '.dependencies | to_entries[] | "- **\(.key)** \(.value)"' package.json

# Detect monorepo
if [ -f "pnpm-workspace.yaml" ] || jq -e '.workspaces' package.json > /dev/null 2>&1; then
  echo "Monorepo detected"
fi
```

### go.mod (Go)

```bash
# Extract direct dependencies
grep -E '^\t[a-zA-Z]' go.mod | awk '{print "- **" $1 "** " $2}'

# Find Go version
grep '^go ' go.mod | awk '{print "Go version: " $2}'
```

### Cargo.toml (Rust)

```bash
# Extract dependencies section
awk '/^\[dependencies\]/,/^\[/' Cargo.toml | grep -v '^\[' | grep -v '^$' | \
  sed 's/\(.*\) = .*/- **\1**/'

# Detect workspace members
grep -A 100 '^\[workspace\]' Cargo.toml | grep 'members' || echo "Single crate"
```

### pom.xml / build.gradle (Java)

```bash
# Maven: extract dependencies
grep -A 2 '<dependency>' pom.xml | grep '<artifactId>' | \
  sed 's/.*<artifactId>\(.*\)<\/artifactId>.*/- **\1**/'

# Gradle: extract implementation dependencies
grep "implementation" build.gradle | sed "s/.*'\(.*\)'.*/- **\1**/"
```

### pyproject.toml / requirements.txt (Python)

```bash
# pyproject.toml dependencies
awk '/^\[project\]/,/^\[/' pyproject.toml | grep -E '^\s+"' | tr -d ' ",' | \
  sed 's/\(.*\)/- **\1**/'

# requirements.txt
grep -v '^#' requirements.txt | grep -v '^$' | sed 's/\(.*\)==.*/- **\1**/'
```

### Import Graph Analysis

For deeper analysis, trace internal imports to understand module coupling:

```bash
# TypeScript/JavaScript: find internal imports
rg "^import .* from '[.@]" --type ts --type tsx -l | head -20

# Python: find internal imports
rg "^from \." --type py -l | head -20

# Go: find internal package imports
rg '"[^"]*internal/' --type go -l | head -20
```

---

## Code Examples

### generate-codemap.sh — Full Bash Implementation

```bash
#!/usr/bin/env bash
#
# generate-codemap.sh — Auto-generate codemap.md for AI context
#
# Usage: ./generate-codemap.sh [project-dir] [output-file]
#
# Requires: fd (or find), jq (optional), rg (optional)
#
set -euo pipefail

PROJECT_DIR="${1:-.}"
OUTPUT="${2:-${PROJECT_DIR}/codemap.md}"
DATE=$(date +%Y-%m-%d)

# --- Utilities ---

has_cmd() { command -v "$1" &>/dev/null; }

# Use fd if available, fall back to find
tree_cmd() {
  local dir="$1"
  local depth="${2:-3}"
  if has_cmd fd; then
    fd --base-directory "$dir" \
       --max-depth "$depth" \
       --exclude node_modules \
       --exclude .git \
       --exclude __pycache__ \
       --exclude .next \
       --exclude target \
       --exclude build \
       --exclude dist \
       --exclude .venv \
       --exclude venv \
       --exclude .mypy_cache \
       --exclude .pytest_cache \
       --strip-cwd-prefix \
       2>/dev/null | sort
  else
    find "$dir" -maxdepth "$depth" \
      -not -path '*/node_modules/*' \
      -not -path '*/.git/*' \
      -not -path '*/__pycache__/*' \
      -not -path '*/.next/*' \
      -not -path '*/target/*' \
      -not -path '*/build/*' \
      -not -path '*/dist/*' \
      -not -path '*/.venv/*' \
      -not -path '*/venv/*' \
      -printf '%P\n' 2>/dev/null | sort
  fi
}

# Count files (excluding filtered dirs)
count_files() {
  local dir="$1"
  if has_cmd fd; then
    fd --type f --base-directory "$dir" \
       --exclude node_modules --exclude .git --exclude __pycache__ \
       --exclude .next --exclude target --exclude build --exclude dist \
       --exclude .venv --exclude venv \
       2>/dev/null | wc -l
  else
    find "$dir" -type f \
      -not -path '*/node_modules/*' -not -path '*/.git/*' \
      -not -path '*/__pycache__/*' -not -path '*/.next/*' \
      -not -path '*/target/*' -not -path '*/build/*' \
      -not -path '*/dist/*' -not -path '*/.venv/*' \
      2>/dev/null | wc -l
  fi
}

# --- Detection Functions ---

detect_language() {
  local dir="$1"
  local langs=()

  [ -f "$dir/tsconfig.json" ] && langs+=("TypeScript")
  [ -f "$dir/jsconfig.json" ] && langs+=("JavaScript")
  [ -f "$dir/go.mod" ] && langs+=("Go")
  [ -f "$dir/Cargo.toml" ] && langs+=("Rust")
  [ -f "$dir/pom.xml" ] || [ -f "$dir/build.gradle" ] || [ -f "$dir/build.gradle.kts" ] && langs+=("Java")
  [ -f "$dir/pyproject.toml" ] || [ -f "$dir/requirements.txt" ] || [ -f "$dir/setup.py" ] && langs+=("Python")
  [ -f "$dir/mix.exs" ] && langs+=("Elixir")
  [ -f "$dir/Gemfile" ] && langs+=("Ruby")

  if [ ${#langs[@]} -eq 0 ]; then
    echo "Unknown"
  else
    printf '%s\n' "${langs[@]}" | paste -sd ', ' -
  fi
}

detect_framework() {
  local dir="$1"

  # JavaScript/TypeScript frameworks
  if [ -f "$dir/next.config.ts" ] || [ -f "$dir/next.config.js" ] || [ -f "$dir/next.config.mjs" ]; then
    echo "Next.js"
    return
  fi
  if [ -f "$dir/angular.json" ]; then
    echo "Angular"
    return
  fi
  if [ -f "$dir/astro.config.mjs" ] || [ -f "$dir/astro.config.ts" ]; then
    echo "Astro"
    return
  fi
  if [ -f "$dir/nuxt.config.ts" ]; then
    echo "Nuxt"
    return
  fi
  if [ -f "$dir/svelte.config.js" ]; then
    echo "SvelteKit"
    return
  fi

  # Python frameworks
  if [ -f "$dir/manage.py" ]; then
    echo "Django"
    return
  fi
  if has_cmd rg && rg -q "fastapi" "$dir/pyproject.toml" 2>/dev/null; then
    echo "FastAPI"
    return
  fi

  # Go frameworks (check go.mod)
  if [ -f "$dir/go.mod" ]; then
    if grep -q "go-chi/chi" "$dir/go.mod" 2>/dev/null; then
      echo "Go (Chi)"
    elif grep -q "gin-gonic/gin" "$dir/go.mod" 2>/dev/null; then
      echo "Go (Gin)"
    else
      echo "Go (stdlib)"
    fi
    return
  fi

  # Java frameworks
  if [ -f "$dir/pom.xml" ] && grep -q "spring-boot" "$dir/pom.xml" 2>/dev/null; then
    echo "Spring Boot"
    return
  fi
  if [ -f "$dir/build.gradle" ] && grep -q "spring-boot" "$dir/build.gradle" 2>/dev/null; then
    echo "Spring Boot"
    return
  fi

  # Rust frameworks
  if [ -f "$dir/Cargo.toml" ]; then
    if grep -q "axum" "$dir/Cargo.toml" 2>/dev/null; then
      echo "Rust (Axum)"
    elif grep -q "actix" "$dir/Cargo.toml" 2>/dev/null; then
      echo "Rust (Actix)"
    else
      echo "Rust"
    fi
    return
  fi

  echo "None detected"
}

detect_package_manager() {
  local dir="$1"
  [ -f "$dir/pnpm-lock.yaml" ] && echo "pnpm" && return
  [ -f "$dir/yarn.lock" ] && echo "yarn" && return
  [ -f "$dir/bun.lockb" ] && echo "bun" && return
  [ -f "$dir/package-lock.json" ] && echo "npm" && return
  [ -f "$dir/go.sum" ] && echo "go modules" && return
  [ -f "$dir/Cargo.lock" ] && echo "cargo" && return
  [ -f "$dir/poetry.lock" ] && echo "poetry" && return
  [ -f "$dir/Pipfile.lock" ] && echo "pipenv" && return
  [ -f "$dir/uv.lock" ] && echo "uv" && return
  echo "unknown"
}

detect_test_framework() {
  local dir="$1"
  local tests=()

  # JS/TS
  [ -f "$dir/vitest.config.ts" ] || [ -f "$dir/vitest.config.js" ] && tests+=("Vitest")
  [ -f "$dir/jest.config.ts" ] || [ -f "$dir/jest.config.js" ] && tests+=("Jest")
  [ -f "$dir/playwright.config.ts" ] && tests+=("Playwright")
  [ -f "$dir/cypress.config.ts" ] || [ -f "$dir/cypress.config.js" ] && tests+=("Cypress")

  # Python
  [ -f "$dir/pytest.ini" ] || [ -f "$dir/conftest.py" ] && tests+=("pytest")
  [ -d "$dir/tests" ] && [ -f "$dir/pyproject.toml" ] && grep -q "pytest" "$dir/pyproject.toml" 2>/dev/null && tests+=("pytest")

  # Go
  if has_cmd fd; then
    fd --base-directory "$dir" '_test.go$' --max-depth 3 -q 2>/dev/null && tests+=("go test")
  fi

  # Rust
  if [ -f "$dir/Cargo.toml" ]; then
    tests+=("cargo test")
  fi

  if [ ${#tests[@]} -eq 0 ]; then
    echo "None detected"
  else
    printf '%s\n' "${tests[@]}" | paste -sd ', ' -
  fi
}

detect_monorepo() {
  local dir="$1"
  [ -f "$dir/pnpm-workspace.yaml" ] && echo "Yes (pnpm workspace)" && return
  [ -f "$dir/lerna.json" ] && echo "Yes (Lerna)" && return
  [ -f "$dir/nx.json" ] && echo "Yes (Nx)" && return
  [ -f "$dir/turbo.json" ] && echo "Yes (Turborepo)" && return
  if [ -f "$dir/Cargo.toml" ] && grep -q '\[workspace\]' "$dir/Cargo.toml" 2>/dev/null; then
    echo "Yes (Cargo workspace)" && return
  fi
  if [ -f "$dir/package.json" ] && has_cmd jq; then
    jq -e '.workspaces' "$dir/package.json" &>/dev/null && echo "Yes (npm workspaces)" && return
  fi
  echo "No"
}

detect_architecture_pattern() {
  local dir="$1"

  # Hexagonal / Clean Architecture
  if [ -d "$dir/src/domain" ] && [ -d "$dir/src/application" ] && [ -d "$dir/src/infrastructure" ]; then
    echo "Hexagonal / Clean Architecture"
    return
  fi

  # DDD
  if [ -d "$dir/src/domain" ] && [ -d "$dir/src/bounded-contexts" ]; then
    echo "Domain-Driven Design"
    return
  fi

  # Feature-based
  if [ -d "$dir/src/features" ] || [ -d "$dir/app/features" ]; then
    echo "Feature-based modular"
    return
  fi

  # MVC
  if [ -d "$dir/controllers" ] || [ -d "$dir/src/controllers" ]; then
    if [ -d "$dir/models" ] || [ -d "$dir/src/models" ]; then
      echo "MVC"
      return
    fi
  fi

  # Layered (Spring-style)
  if [ -d "$dir/src/main/java" ]; then
    echo "Layered (Spring convention)"
    return
  fi

  # Standard Go layout
  if [ -d "$dir/cmd" ] && [ -d "$dir/internal" ]; then
    echo "Standard Go Project Layout"
    return
  fi

  echo "Flat / Convention-based"
}

# --- Key Dependencies ---

extract_dependencies() {
  local dir="$1"

  # Node.js
  if [ -f "$dir/package.json" ] && has_cmd jq; then
    local deps
    deps=$(jq -r '.dependencies // {} | to_entries[:10][] | "- **\(.key)** \(.value)"' "$dir/package.json" 2>/dev/null)
    if [ -n "$deps" ]; then
      echo "$deps"
      return
    fi
  fi

  # Go
  if [ -f "$dir/go.mod" ]; then
    grep -E '^\t[a-zA-Z]' "$dir/go.mod" 2>/dev/null | head -10 | \
      awk '{print "- **" $1 "** " $2}'
    return
  fi

  # Python
  if [ -f "$dir/pyproject.toml" ]; then
    awk '/^dependencies/,/^\]/' "$dir/pyproject.toml" 2>/dev/null | \
      grep -E '^\s+"' | tr -d ' ",' | head -10 | \
      sed 's/\(.*\)/- **\1**/'
    return
  fi
  if [ -f "$dir/requirements.txt" ]; then
    grep -v '^#' "$dir/requirements.txt" | grep -v '^$' | head -10 | \
      sed 's/\([a-zA-Z0-9_-]*\).*/- **\1**/'
    return
  fi

  # Rust
  if [ -f "$dir/Cargo.toml" ]; then
    awk '/^\[dependencies\]/,/^\[/' "$dir/Cargo.toml" 2>/dev/null | \
      grep -v '^\[' | grep -v '^$' | head -10 | \
      sed 's/\([a-zA-Z0-9_-]*\).*/- **\1**/'
    return
  fi

  echo "- (Could not auto-detect dependencies)"
}

# --- Entry Points ---

find_entry_points() {
  local dir="$1"
  local entries=()

  # Next.js
  [ -f "$dir/app/layout.tsx" ] && entries+=("app/layout.tsx — Root layout")
  [ -f "$dir/app/page.tsx" ] && entries+=("app/page.tsx — Home route")
  [ -f "$dir/pages/_app.tsx" ] && entries+=("pages/_app.tsx — App wrapper")
  [ -f "$dir/middleware.ts" ] && entries+=("middleware.ts — Request middleware")

  # General JS/TS
  [ -f "$dir/src/index.ts" ] && entries+=("src/index.ts — Main entry")
  [ -f "$dir/src/main.ts" ] && entries+=("src/main.ts — Main entry")
  [ -f "$dir/src/App.tsx" ] && entries+=("src/App.tsx — App component")
  [ -f "$dir/index.ts" ] && entries+=("index.ts — Package entry")

  # Go
  [ -f "$dir/main.go" ] && entries+=("main.go — Main entry")
  [ -f "$dir/cmd/server/main.go" ] && entries+=("cmd/server/main.go — Server entry")
  if [ -d "$dir/cmd" ]; then
    for cmd_dir in "$dir"/cmd/*/; do
      [ -f "${cmd_dir}main.go" ] && entries+=("${cmd_dir#$dir/}main.go — CLI entry")
    done
  fi

  # Python
  [ -f "$dir/manage.py" ] && entries+=("manage.py — Django management")
  [ -f "$dir/app/main.py" ] && entries+=("app/main.py — FastAPI entry")
  [ -f "$dir/main.py" ] && entries+=("main.py — Main entry")
  [ -f "$dir/src/main.py" ] && entries+=("src/main.py — Main entry")

  # Rust
  [ -f "$dir/src/main.rs" ] && entries+=("src/main.rs — Binary entry")
  [ -f "$dir/src/lib.rs" ] && entries+=("src/lib.rs — Library entry")

  # Java
  if has_cmd rg; then
    local spring_main
    spring_main=$(rg -l "@SpringBootApplication" "$dir/src" 2>/dev/null | head -1)
    [ -n "$spring_main" ] && entries+=("${spring_main#$dir/} — Spring Boot entry")
  fi

  # Config files (always relevant)
  for cfg in Dockerfile docker-compose.yml Makefile Justfile; do
    [ -f "$dir/$cfg" ] && entries+=("$cfg — Build/deploy config")
  done

  if [ ${#entries[@]} -eq 0 ]; then
    echo "- (No standard entry points detected)"
  else
    for entry in "${entries[@]}"; do
      echo "- \`${entry%%—*}\` —${entry#*—}"
    done
  fi
}

# --- Generate the Codemap ---

generate_codemap() {
  local dir
  dir=$(cd "$PROJECT_DIR" && pwd)
  local name
  name=$(basename "$dir")

  local file_count
  file_count=$(count_files "$dir")

  # Determine depth based on project size
  local depth=3
  if [ "$file_count" -gt 1000 ]; then
    depth=2
  elif [ "$file_count" -lt 100 ]; then
    depth=5
  fi

  cat <<HEADER
# Codebase Map

> Auto-generated by codebase-cartography. Last updated: ${DATE}

## Project Overview

- **Name**: ${name}
- **Language**: $(detect_language "$dir")
- **Framework**: $(detect_framework "$dir")
- **Package Manager**: $(detect_package_manager "$dir")
- **Monorepo**: $(detect_monorepo "$dir")
- **Test Framework**: $(detect_test_framework "$dir")
- **Total Files**: ${file_count} (excluding build artifacts)

## Architecture

**Pattern**: $(detect_architecture_pattern "$dir")

## Directory Structure

\`\`\`
$(tree_cmd "$dir" "$depth" | head -80)
\`\`\`

## Key Files

$(find_entry_points "$dir")

## Dependencies (Top 10)

$(extract_dependencies "$dir")

## Patterns Detected

$(detect_architecture_pattern "$dir")
HEADER
}

# --- Main ---

echo "Generating codemap for: $(cd "$PROJECT_DIR" && pwd)"
echo "Output: $OUTPUT"

generate_codemap > "$OUTPUT"

echo ""
echo "Done! codemap.md written to $OUTPUT"
echo "Token estimate: ~$(wc -w < "$OUTPUT") words (aim for <1500)"
```

### Simplified Version with fd + rg

For quick one-off generation when you don't need the full script:

```bash
#!/usr/bin/env bash
# quick-codemap.sh — Minimal codemap generator using fd and rg
set -euo pipefail

DIR="${1:-.}"
NAME=$(basename "$(cd "$DIR" && pwd)")

echo "# Codebase Map — ${NAME}"
echo ""
echo "> Generated: $(date +%Y-%m-%d)"
echo ""

# Project overview
echo "## Structure"
echo ""
echo '```'
fd --base-directory "$DIR" --max-depth 3 \
   -E node_modules -E .git -E __pycache__ -E .next -E target -E build -E dist \
   --strip-cwd-prefix 2>/dev/null | head -60
echo '```'
echo ""

# Key config files
echo "## Config Files"
echo ""
for f in package.json tsconfig.json go.mod Cargo.toml pyproject.toml \
         Dockerfile docker-compose.yml Makefile next.config.ts angular.json; do
  [ -f "$DIR/$f" ] && echo "- \`$f\`"
done
echo ""

# Dependencies
echo "## Key Dependencies"
echo ""
if [ -f "$DIR/package.json" ] && command -v jq &>/dev/null; then
  jq -r '.dependencies // {} | keys[:8][]' "$DIR/package.json" 2>/dev/null | \
    sed 's/^/- /'
elif [ -f "$DIR/go.mod" ]; then
  grep -E '^\t' "$DIR/go.mod" | head -8 | awk '{print "- " $1}'
elif [ -f "$DIR/Cargo.toml" ]; then
  awk '/^\[dependencies\]/,/^\[/' "$DIR/Cargo.toml" | grep -v '^\[' | \
    grep -v '^$' | head -8 | sed 's/ .*//' | sed 's/^/- /'
fi
```

---

## Integration with AI Tools

### Placement and Auto-Loading

Place `codemap.md` in the **project root**. Most AI coding tools automatically load
root-level markdown files as context:

| Tool        | Auto-loads from root                    | Reference mechanism             |
|-------------|-----------------------------------------|---------------------------------|
| Claude Code | Yes (via CLAUDE.md or direct reference) | Add `See codemap.md` to CLAUDE.md |
| OpenCode    | Yes (via QWEN.md/agents config)        | Reference in agent instructions |
| Cursor      | Yes (via .cursorrules)                  | Include in rules file           |
| Aider       | Via `--read` flag                       | `aider --read codemap.md`      |
| Copilot     | Via workspace context                   | Reference in .github/copilot    |

### CLAUDE.md Integration

Add this to your `CLAUDE.md`:

```markdown
## Project Map

See `codemap.md` for the full directory structure, architecture patterns,
and dependency overview. Consult it before exploring unfamiliar areas.
```

### Token Budget Management

The codemap should be a **net token saver**. It costs ~500-2000 tokens to load but
saves 5000-20000 tokens that would otherwise be spent on exploration:

```
Without codemap:
  Agent explores → 15 tool calls → 8000 tokens consumed → finds the right file

With codemap:
  Agent reads codemap → 800 tokens → knows where to look → 2 tool calls → done
```

**Rules for staying within budget:**
- Max 80 files in directory tree listing
- Max 10 key dependencies listed
- Max 10 entry points listed
- Use comments/annotations sparingly
- No file contents — only structure

### Refresh Strategy

Regenerate `codemap.md` when:

1. **New module/package added** — the architecture shape changed
2. **Framework migration** — e.g., Pages Router → App Router
3. **Major dependency change** — new ORM, new state management
4. **CI/CD change** — new deploy target, new pipeline
5. **Quarterly review** — even if nothing major changed, verify accuracy

**Do NOT regenerate** for:
- Adding new files within existing modules
- Updating dependency versions (minor/patch)
- Bug fixes that don't change architecture
- Adding tests within existing test directories

### Using with SDD Explore

When starting SDD exploration on an unfamiliar codebase:

```
User: /sdd:explore payment-refunds

Agent (with codemap):
  1. Reads codemap.md → sees `services/payments/` exists
  2. Knows it's a Spring Boot app with JPA repositories
  3. Jumps directly to `services/payments/RefundService.java`
  4. Completes exploration in 3 tool calls instead of 15
```

---

## Anti-Patterns

### 1. Including File Contents

**Wrong:**
```markdown
## Key Files
### src/main.ts
```typescript
import { createApp } from './app';
const app = createApp();
app.listen(3000);
```
```

**Right:**
```markdown
## Key Files
- `src/main.ts` — Application entry point, creates and starts HTTP server
```

**Why**: File contents bloat the codemap and become stale. The codemap should tell
the AI *where* to look, not *what* it will find.

### 2. Listing Every File in Large Projects

**Wrong:**
```markdown
## Directory Structure
```
src/
├── components/
│   ├── Button.tsx
│   ├── ButtonGroup.tsx
│   ├── Card.tsx
│   ├── CardBody.tsx
│   ├── CardHeader.tsx
│   ├── CardFooter.tsx
│   ... (200 more files)
```
```

**Right:**
```markdown
## Directory Structure
```
src/
├── components/          # 47 UI components (Mantine-based)
│   ├── ui/              # Primitive components
│   ├── features/        # Feature-specific components
│   └── layout/          # Layout components
```
```

**Why**: The AI doesn't need to know every component name. It needs to know
*where components live* and *how they're organized*.

### 3. Hardcoding Absolute Paths

**Wrong:**
```markdown
- Entry: `/Users/javier/projects/my-app/src/main.ts`
```

**Right:**
```markdown
- Entry: `src/main.ts`
```

**Why**: Absolute paths are machine-specific and break when shared.

### 4. Forgetting to Update

A stale codemap is **worse than no codemap** — it actively misleads the AI into
looking for files and patterns that no longer exist.

**Mitigation strategies:**
- Add codemap generation to CI (run on `main` branch merges)
- Add a pre-commit hook that warns if architecture files changed but codemap didn't
- Include the generation date in the codemap header
- Set a calendar reminder for quarterly review

### 5. Over-Annotating

**Wrong:**
```markdown
## Directory Structure
```
src/
├── components/     # This directory contains all React components used across the application
│   ├── ui/         # These are the primitive UI components based on the design system
│   └── features/   # Feature-specific components that are only used in their respective features
├── hooks/          # Custom React hooks for shared stateful logic across components
```
```

**Right:**
```markdown
## Directory Structure
```
src/
├── components/
│   ├── ui/              # Design system primitives
│   └── features/        # Feature-scoped
├── hooks/
```
```

**Why**: Annotations should be terse. The codemap is for orientation, not documentation.

### 6. Mixing Concerns

The codemap should capture **static architecture**, not:
- Runtime behavior ("this endpoint handles 1000 req/s")
- Business logic ("users must verify email before purchase")
- Deployment topology ("runs on 3 ECS tasks behind ALB")
- Team ownership ("team-payments owns this module")

Keep those in separate documents (ARCHITECTURE.md, RUNBOOK.md, CODEOWNERS).

---

## Example Outputs

### Next.js 15 App

```markdown
# Codebase Map

> Auto-generated by codebase-cartography. Last updated: 2026-03-01

## Project Overview

- **Name**: acme-dashboard
- **Language**: TypeScript
- **Framework**: Next.js 15 (App Router)
- **Package Manager**: pnpm
- **Monorepo**: No
- **Test Framework**: Vitest, Playwright

## Architecture

**Pattern**: Feature-based with App Router conventions

## Directory Structure

```
acme-dashboard/
├── app/
│   ├── (auth)/login/
│   ├── (auth)/register/
│   ├── dashboard/
│   ├── settings/
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   ├── ui/
│   └── features/
├── lib/
│   ├── db.ts
│   ├── auth.ts
│   └── validators/
├── services/
├── hooks/
├── e2e/
├── next.config.ts
└── package.json
```

## Entry Points

- `app/layout.tsx` — Root layout with providers
- `app/page.tsx` — Landing page
- `middleware.ts` — Auth guard middleware
- `next.config.ts` — Build configuration

## Dependencies (Key)

- **next** ^15.0.0
- **react** ^19.0.0
- **drizzle-orm** ^0.35.0
- **next-auth** ^5.0.0
- **zod** ^4.0.0
- **tailwindcss** ^4.0.0
```

### Go Microservice

```markdown
# Codebase Map

> Auto-generated by codebase-cartography. Last updated: 2026-03-01

## Project Overview

- **Name**: order-service
- **Language**: Go
- **Framework**: Go (Chi)
- **Package Manager**: go modules
- **Monorepo**: No
- **Test Framework**: go test
- **Go Version**: 1.23

## Architecture

**Pattern**: Standard Go Project Layout with Clean Architecture

## Directory Structure

```
order-service/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── domain/
│   │   ├── order.go
│   │   └── payment.go
│   ├── handler/
│   │   └── order_handler.go
│   ├── repository/
│   │   ├── postgres/
│   │   └── redis/
│   └── service/
│       └── order_service.go
├── pkg/
│   ├── middleware/
│   └── httputil/
├── migrations/
├── deployments/
│   ├── Dockerfile
│   └── k8s/
├── go.mod
├── go.sum
└── Makefile
```

## Entry Points

- `cmd/server/main.go` — HTTP server entry
- `Makefile` — Build and dev commands
- `deployments/Dockerfile` — Container build

## Dependencies (Key)

- **github.com/go-chi/chi/v5** — HTTP router
- **github.com/jackc/pgx/v5** — PostgreSQL driver
- **github.com/redis/go-redis/v9** — Redis client
- **go.uber.org/zap** — Structured logging
- **github.com/golang-jwt/jwt/v5** — JWT auth
```

### Spring Boot API

```markdown
# Codebase Map

> Auto-generated by codebase-cartography. Last updated: 2026-03-01

## Project Overview

- **Name**: inventory-api
- **Language**: Java 21
- **Framework**: Spring Boot 3.3
- **Package Manager**: Gradle (Kotlin DSL)
- **Monorepo**: No
- **Test Framework**: JUnit 5, TestContainers

## Architecture

**Pattern**: Layered (Controller → Service → Repository)

## Directory Structure

```
inventory-api/
├── src/main/java/com/acme/inventory/
│   ├── InventoryApplication.java
│   ├── config/
│   │   ├── SecurityConfig.java
│   │   └── OpenApiConfig.java
│   ├── controller/
│   │   ├── ProductController.java
│   │   └── StockController.java
│   ├── service/
│   │   ├── ProductService.java
│   │   └── StockService.java
│   ├── repository/
│   │   ├── ProductRepository.java
│   │   └── StockRepository.java
│   ├── entity/
│   │   ├── Product.java
│   │   └── StockEntry.java
│   ├── dto/
│   └── exception/
├── src/main/resources/
│   ├── application.yml
│   └── db/migration/
├── src/test/
├── build.gradle.kts
├── Dockerfile
└── docker-compose.yml
```

## Entry Points

- `InventoryApplication.java` — @SpringBootApplication main
- `application.yml` — Configuration (profiles: dev, prod)
- `build.gradle.kts` — Build configuration
- `Dockerfile` — Container build

## Dependencies (Key)

- **spring-boot-starter-web** — REST API
- **spring-boot-starter-data-jpa** — ORM
- **spring-boot-starter-security** — Auth
- **springdoc-openapi** — API docs
- **postgresql** — Database driver
- **flyway** — Migrations
- **testcontainers** — Integration tests
```

---

## Quick Reference

### Generate Command

```bash
# Full generation
./generate-codemap.sh . codemap.md

# Quick generation (fd + rg)
./quick-codemap.sh . > codemap.md

# Regenerate on architecture changes (Git hook)
# .git/hooks/post-merge
#!/bin/sh
changed=$(git diff HEAD@{1} --name-only | grep -E '(package\.json|go\.mod|Cargo\.toml|angular\.json|next\.config)')
if [ -n "$changed" ]; then
  echo "Architecture file changed — regenerating codemap.md"
  ./generate-codemap.sh . codemap.md
fi
```

### Checklist Before Committing codemap.md

- [ ] Under 2000 tokens (~1500 words)
- [ ] No absolute paths
- [ ] No file contents (structure only)
- [ ] No secrets or sensitive config values
- [ ] Date header is current
- [ ] Framework/language detection is accurate
- [ ] Key entry points are listed
- [ ] Top dependencies are listed (max 10)
- [ ] Architecture pattern description is accurate
- [ ] Directory tree depth is appropriate for project size
